# Лабораторная работа №1

Выполнила студентка гр. БСТ2201 Прохорова Наталья

## Описание
*Задание №1*

***Вызвать функцию print() и передать туда строку Hello, World!***

*Задание №2*

***Написать генератор случайных матриц(многомерных), который принимает опциональные параметры m, n, min_limit, max_limit, где m и n указывают размер матрицы, а min_lim и max_lim - минимальное и максимальное значение для генерируемого числа.***

*Задание №3*

***Реализовать методы сортировки строк (выбором, вставкой, пузырьком, Шелла, быстрая, турнирная) числовой матрицы в соответствии с заданием. Оценить время работы каждого алгоритма сортировки и сравнить его со временем стандартной функции сортировки. Испытания проводить на сгенерированных матрицах.***

## Выполнение

*В задании 1 нужно вызвать функцию print() и передать строку Hello World!*

**Задание 1 представлено в 1.py**
```python
print("Hello World!")
```
*В задании 2 нужно написать генератор случайных многомерных матриц (возможность ввода значений предоставляется пользователю)*

**Задание 2 представлено в 2.py**

```python
def generateRandomMatrix(m=None, n=None, min_limit=0, max_limit=100):

matrix = []
for i in range(m):
    row = []
    for j in range(n):
        num = random.randint(min_limit, max_limit)  # случайное значение в заданном диапазоне
        row.append(num)
    matrix.append(row)

return matrix

m = int(input("Введите количество строк матрицы: "))
n = int(input("Введите количество столбцов матрицы: "))
min_limit = int(input("Введите минимальное значение: "))
max_limit = int(input("Введите максимальное значение: "))

random_matrix = generateRandomMatrix(m, n, min_limit, max_limit)
print("Вывод матрицы:")
for row in random_matrix:
    print(row)
```
В задании 3 нужно реализовать методы сортировки строк матриц*

**Задание 3 представлено в 3.py**

### Сортировка вставкой
Сортировка матрицы вставкой работает построчно. На каждом шаге берется текущая строка и ее элементы последовательно вставляются в уже отсортированную часть этой строки. Элементы до вставляемого элемента сдвигаются вправо, чтобы освободить место для вставки. Таким образом, на каждом шаге строка становится все более отсортированной, пока в конечном итоге вся матрица не будет отсортирована.

```python
def insertion_sort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i-1
        while j >= 0 and key < arr[j]:
            arr[j+1] = arr[j]
            j -= 1
        arr[j+1] = key
    return arr
```
### Сортировка пузырьком (обменом)
Сортировка матрицы пузырьком - это алгоритм сортировки, который использует циклы проходов по матрице для перемещения наибольшего или наименьшего элемента на нужную позицию. При каждом проходе сравниваются пары соседних элементов и меняются местами, если это необходимо. Процесс повторяется до тех пор, пока все элементы матрицы не будут отсортированы по возрастанию или убыванию.

```python
def bubble_sort(arr):
    n = len(arr)
    for i in range(n-1):
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr
```
### Сортировка выбором
Сортировка матрицы выбором работает следующим образом: на каждом шаге выбирается наименьший элемент и помещается в начало соответствующей строки. Затем это повторяется для оставшихся элементов матрицы, пока не будет достигнут конец матрицы. В результате каждая строка матрицы будет отсортирована в порядке возрастания.

```python
def selection_sort(arr):
    for i in range(len(arr)):
        min_idx = i
        for j in range(i+1, len(arr)):
            if arr[j] < arr[min_idx]:
                min_idx = j
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    return arr
```
### Сортировка Шелла
Сортировка матрицы Шелла основывается на идее постепенного уточнения порядка элементов в матрице. Сначала выбирается некоторое начальное значение интервала (обычно половина размера матрицы), а затем все элементы, находящиеся на этом интервале, сравниваются и переставляются в соответствии с заданным порядком. После этого интервал уменьшается вдвое, и процесс повторяется, пока интервал не станет равным единице. В результате таких итераций элементы в матрице перемещаются постепенно к своим конечным позициям, что приводит к отсортированной матрице.

```python
def shell_sort(arr):
    n = len(arr)
    gap = n // 2
    while gap > 0:
        for i in range(gap, n):
            temp = arr[i]
            j = i
            while j >= gap and arr[j-gap] > temp:
                arr[j] = arr[j-gap]
                j -= gap
            arr[j] = temp
        gap //= 2
    return arr
```
### Быстрая сортировка
Быстрая сортировка матрицы работает следующим образом: сначала выбирается опорный элемент из матрицы, обычно это средний элемент. Затем матрица разделяется на две части: элементы меньше опорного и элементы больше опорного. Далее процесс повторяется для каждой части - выбирается новый опорный элемент и матрица разделяется на две. Этот процесс продолжается до тех пор, пока не будет достигнута базовая точка, например, когда каждая часть матрицы содержит только один элемент. В результате все элементы матрицы становятся упорядоченными.

```python
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr)//2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)
```
### Турнирная сортировка
Производится преобразование списка в бинарное дерево, где вершина является наибольшим элементом, а самый большой элемент помещается в конец списка. После этого происходит перестроение дерева, при этом новый наибольший элемент помещается перед последним элементом списка. Этот алгоритм повторяется до полного удаления всех вершин дерева.

```python
def tournament_sort(arr):
    def heapify(arr, n, i):
        largest = i
        l = 2 * i + 1
        r = 2 * i + 2
        if l < n and arr[i] < arr[l]:
            largest = l
        if r < n and arr[largest] < arr[r]:
            largest = r
        if largest != i:
            arr[i], arr[largest] = arr[largest], arr[i]
            heapify(arr, n, largest)

def build_max_heap(arr):
    n = len(arr)
    for i in range(n//2 - 1, -1, -1):
        heapify(arr, n, i)

def tournament(arr):
    n = len(arr)
    build_max_heap(arr)
    for i in range(n-1, 0, -1):
        arr[0], arr[i] = arr[i], arr[0]
        heapify(arr, i, 0)

tournament(arr)
return arr
```
## Замеры времени работы алгоритмов сортировки

### Матрица 50x50:

```
Выбором - 0.121968 сек

Вставкой - 0.001002 сек

Пузырьком - 0.163999 сек

Шелла - 0.002978 сек

Быстрая - 0.000988 сек

Турнирная - 0.005999 сек

Стандарт - 0.000000 сек
```
### Матрица 150x150:
```
Выбором - 9.815012 сек

Вставкой - 0.002988 сек

Пузырьком - 13.843001 сек

Шелла - 0.030028 сек

Быстрая - 0.012020 сек

Турнирная - 0.074010 сек

Стандарт - 0.000000 сек
```
